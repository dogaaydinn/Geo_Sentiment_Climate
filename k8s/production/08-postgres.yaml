# PostgreSQL Database for Geo Climate Platform
#
# High-Availability Setup:
# - StatefulSet with stable network identities
# - Primary-replica replication
# - Automated backups
# - PgBouncer connection pooling
# - Monitoring with postgres_exporter
#
# Usage:
#   kubectl apply -f k8s/production/08-postgres.yaml
#
# Access:
#   # From within cluster
#   psql -h postgres-0.postgres-headless.geo-climate.svc.cluster.local -U geo_climate
#
#   # Port-forward for local access
#   kubectl port-forward -n geo-climate postgres-0 5432:5432

---
# ============================================================================
# PostgreSQL ConfigMap
# ============================================================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-config
  namespace: geo-climate
  labels:
    app: postgres
data:
  # PostgreSQL configuration
  postgresql.conf: |
    # Connection Settings
    listen_addresses = '*'
    port = 5432
    max_connections = 200
    superuser_reserved_connections = 3

    # Memory Settings (for 4GB RAM container)
    shared_buffers = 1GB
    effective_cache_size = 3GB
    maintenance_work_mem = 256MB
    work_mem = 10MB

    # WAL Settings (Write-Ahead Logging)
    wal_level = replica
    max_wal_senders = 10
    max_replication_slots = 10
    wal_keep_size = 1GB
    hot_standby = on
    hot_standby_feedback = on

    # Checkpoint Settings
    checkpoint_timeout = 15min
    checkpoint_completion_target = 0.9
    max_wal_size = 2GB
    min_wal_size = 1GB

    # Query Performance
    random_page_cost = 1.1  # For SSD storage
    effective_io_concurrency = 200

    # Logging
    log_destination = 'stderr'
    logging_collector = on
    log_directory = '/var/log/postgresql'
    log_filename = 'postgresql-%Y-%m-%d.log'
    log_rotation_age = 1d
    log_rotation_size = 100MB
    log_min_duration_statement = 1000  # Log queries > 1s
    log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
    log_statement = 'ddl'  # Log DDL statements

    # Performance Monitoring
    shared_preload_libraries = 'pg_stat_statements'
    pg_stat_statements.track = all
    pg_stat_statements.max = 10000

    # Autovacuum
    autovacuum = on
    autovacuum_max_workers = 3
    autovacuum_naptime = 1min

  # pg_hba.conf - Client authentication
  pg_hba.conf: |
    # TYPE  DATABASE        USER            ADDRESS                 METHOD

    # Local connections
    local   all             all                                     trust

    # IPv4 local connections
    host    all             all             127.0.0.1/32            trust

    # Allow replication connections
    host    replication     replicator      0.0.0.0/0               md5

    # Allow connections from pods
    host    all             all             0.0.0.0/0               md5

    # IPv6 connections
    host    all             all             ::1/128                 trust

  # Initialization script
  init-db.sh: |
    #!/bin/bash
    set -e

    # Wait for PostgreSQL to be ready
    until pg_isready -U postgres; do
      echo "Waiting for PostgreSQL..."
      sleep 2
    done

    # Create database if not exists
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
      SELECT 'CREATE DATABASE ${POSTGRES_DB}'
      WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '${POSTGRES_DB}')\gexec
    EOSQL

    # Create extensions
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
      CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
      CREATE EXTENSION IF NOT EXISTS pg_trgm;
      CREATE EXTENSION IF NOT EXISTS btree_gin;
      CREATE EXTENSION IF NOT EXISTS btree_gist;
      CREATE EXTENSION IF NOT EXISTS pgcrypto;
    EOSQL

    echo "Database initialization complete!"

---
# ============================================================================
# PostgreSQL Headless Service (for StatefulSet)
# ============================================================================

apiVersion: v1
kind: Service
metadata:
  name: postgres-headless
  namespace: geo-climate
  labels:
    app: postgres
spec:
  type: ClusterIP
  clusterIP: None  # Headless service
  ports:
    - name: postgresql
      port: 5432
      targetPort: 5432
      protocol: TCP
  selector:
    app: postgres

---
# PostgreSQL Service (for external access)
apiVersion: v1
kind: Service
metadata:
  name: postgres
  namespace: geo-climate
  labels:
    app: postgres
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9187"
spec:
  type: ClusterIP
  ports:
    - name: postgresql
      port: 5432
      targetPort: 5432
      protocol: TCP
    - name: metrics
      port: 9187
      targetPort: 9187
      protocol: TCP
  selector:
    app: postgres
    role: primary  # Route to primary only

---
# ============================================================================
# PostgreSQL StatefulSet
# ============================================================================

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: geo-climate
  labels:
    app: postgres
spec:
  serviceName: postgres-headless
  replicas: 1  # Start with 1, scale to 3 for HA
  selector:
    matchLabels:
      app: postgres

  # Pod Management Policy
  podManagementPolicy: OrderedReady
  updateStrategy:
    type: RollingUpdate

  template:
    metadata:
      labels:
        app: postgres
        role: primary
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9187"

    spec:
      serviceAccountName: geo-climate-api

      # Security Context
      securityContext:
        fsGroup: 999  # postgres user
        runAsUser: 999
        runAsNonRoot: true

      # Init containers
      initContainers:
        # Set proper permissions
        - name: init-chmod
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              mkdir -p /var/lib/postgresql/data
              chown -R 999:999 /var/lib/postgresql/data
              chmod 0700 /var/lib/postgresql/data
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
          securityContext:
            runAsUser: 0  # Run as root for chown

      containers:
        # PostgreSQL container
        - name: postgres
          image: postgres:15.5-alpine
          imagePullPolicy: IfNotPresent

          ports:
            - name: postgresql
              containerPort: 5432
              protocol: TCP

          env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: postgres-secrets
                  key: POSTGRES_USER
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-secrets
                  key: POSTGRES_PASSWORD
            - name: POSTGRES_DB
              valueFrom:
                secretKeyRef:
                  name: postgres-secrets
                  key: POSTGRES_DB
            - name: PGDATA
              value: /var/lib/postgresql/data/pgdata
            - name: POD_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP

          # Resource limits
          resources:
            requests:
              memory: "2Gi"
              cpu: "500m"
            limits:
              memory: "4Gi"
              cpu: "2000m"

          # Liveness probe
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3

          # Readiness probe
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3

          # Startup probe
          startupProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 30  # 150 seconds max startup time

          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
            - name: postgres-config
              mountPath: /etc/postgresql/postgresql.conf
              subPath: postgresql.conf
            - name: postgres-config
              mountPath: /etc/postgresql/pg_hba.conf
              subPath: pg_hba.conf
            - name: postgres-config
              mountPath: /docker-entrypoint-initdb.d/init-db.sh
              subPath: init-db.sh

          # Security context
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL

        # Postgres Exporter for Prometheus metrics
        - name: postgres-exporter
          image: prometheuscommunity/postgres-exporter:v0.15.0
          imagePullPolicy: IfNotPresent

          ports:
            - name: metrics
              containerPort: 9187
              protocol: TCP

          env:
            - name: DATA_SOURCE_NAME
              valueFrom:
                secretKeyRef:
                  name: postgres-secrets
                  key: DATABASE_URL
            - name: PG_EXPORTER_AUTO_DISCOVER_DATABASES
              value: "true"

          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "128Mi"
              cpu: "100m"

          livenessProbe:
            httpGet:
              path: /metrics
              port: 9187
            initialDelaySeconds: 30
            periodSeconds: 10

          readinessProbe:
            httpGet:
              path: /metrics
              port: 9187
            initialDelaySeconds: 10
            periodSeconds: 5

          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 65534  # nobody

      volumes:
        - name: postgres-config
          configMap:
            name: postgres-config
            defaultMode: 0755

  # Volume Claim Templates
  volumeClaimTemplates:
    - metadata:
        name: postgres-data
        labels:
          app: postgres
      spec:
        accessModes:
          - ReadWriteOnce
        storageClassName: fast-ssd
        resources:
          requests:
            storage: 100Gi

---
# ============================================================================
# PgBouncer - Connection Pooling
# ============================================================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: pgbouncer-config
  namespace: geo-climate
  labels:
    app: pgbouncer
data:
  pgbouncer.ini: |
    [databases]
    * = host=postgres port=5432

    [pgbouncer]
    listen_addr = 0.0.0.0
    listen_port = 6432
    auth_type = md5
    auth_file = /etc/pgbouncer/userlist.txt

    # Connection pooling
    pool_mode = transaction
    max_client_conn = 1000
    default_pool_size = 25
    reserve_pool_size = 10
    reserve_pool_timeout = 5

    # Logging
    log_connections = 0
    log_disconnections = 0
    log_pooler_errors = 1

    # Timeouts
    server_idle_timeout = 600
    server_lifetime = 3600
    server_connect_timeout = 15
    query_timeout = 0
    query_wait_timeout = 120
    client_idle_timeout = 0
    idle_transaction_timeout = 0

    # Performance
    pkt_buf = 8192
    max_packet_size = 2147483647

  userlist.txt: |
    "geo_climate" "CHANGE_ME_PLEASE!!!"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pgbouncer
  namespace: geo-climate
  labels:
    app: pgbouncer
spec:
  replicas: 2
  selector:
    matchLabels:
      app: pgbouncer
  template:
    metadata:
      labels:
        app: pgbouncer
    spec:
      containers:
        - name: pgbouncer
          image: edoburu/pgbouncer:1.21.0
          imagePullPolicy: IfNotPresent

          ports:
            - name: pgbouncer
              containerPort: 6432
              protocol: TCP

          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"

          livenessProbe:
            tcpSocket:
              port: 6432
            initialDelaySeconds: 10
            periodSeconds: 10

          readinessProbe:
            tcpSocket:
              port: 6432
            initialDelaySeconds: 5
            periodSeconds: 5

          volumeMounts:
            - name: pgbouncer-config
              mountPath: /etc/pgbouncer/pgbouncer.ini
              subPath: pgbouncer.ini
            - name: pgbouncer-config
              mountPath: /etc/pgbouncer/userlist.txt
              subPath: userlist.txt

      volumes:
        - name: pgbouncer-config
          configMap:
            name: pgbouncer-config

---
apiVersion: v1
kind: Service
metadata:
  name: pgbouncer
  namespace: geo-climate
  labels:
    app: pgbouncer
spec:
  type: ClusterIP
  ports:
    - name: pgbouncer
      port: 5432
      targetPort: 6432
      protocol: TCP
  selector:
    app: pgbouncer

---
# ============================================================================
# Backup CronJob
# ============================================================================

apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-backup
  namespace: geo-climate
  labels:
    app: postgres-backup
spec:
  # Run daily at 2 AM
  schedule: "0 2 * * *"

  # Keep last 3 successful jobs
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3

  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: postgres-backup
        spec:
          restartPolicy: OnFailure

          containers:
            - name: backup
              image: postgres:15.5-alpine
              imagePullPolicy: IfNotPresent

              command:
                - /bin/sh
                - -c
                - |
                  set -e

                  TIMESTAMP=$(date +%Y%m%d_%H%M%S)
                  BACKUP_FILE="/backups/geo_climate_${TIMESTAMP}.sql.gz"

                  echo "Starting backup at ${TIMESTAMP}..."

                  # Full database dump
                  pg_dump -h postgres -U $POSTGRES_USER -d $POSTGRES_DB --clean --if-exists | \
                    gzip > ${BACKUP_FILE}

                  echo "Backup completed: ${BACKUP_FILE}"

                  # Get file size
                  ls -lh ${BACKUP_FILE}

                  # Cleanup old backups (keep last 30 days)
                  echo "Cleaning up old backups..."
                  find /backups -name "geo_climate_*.sql.gz" -mtime +30 -delete

                  echo "Backup process finished!"

              env:
                - name: POSTGRES_USER
                  valueFrom:
                    secretKeyRef:
                      name: postgres-secrets
                      key: POSTGRES_USER
                - name: POSTGRES_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: postgres-secrets
                      key: POSTGRES_PASSWORD
                - name: POSTGRES_DB
                  valueFrom:
                    secretKeyRef:
                      name: postgres-secrets
                      key: POSTGRES_DB
                - name: PGPASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: postgres-secrets
                      key: POSTGRES_PASSWORD

              resources:
                requests:
                  memory: "256Mi"
                  cpu: "100m"
                limits:
                  memory: "512Mi"
                  cpu: "500m"

              volumeMounts:
                - name: backups
                  mountPath: /backups

          volumes:
            - name: backups
              persistentVolumeClaim:
                claimName: db-backups-pvc

---
# ============================================================================
# PRODUCTION DEPLOYMENT NOTES
# ============================================================================
#
# 1. HIGH AVAILABILITY SETUP
# ---------------------------
# For production HA, use PostgreSQL replication:
#
# Scale StatefulSet to 3 replicas:
#   kubectl scale statefulset postgres --replicas=3 -n geo-climate
#
# Configure replication (automated with operators like Zalando, Crunchy, CloudNativePG):
#   - postgres-0: Primary (read-write)
#   - postgres-1, postgres-2: Replicas (read-only)
#
# Use PostgreSQL Operator for automated failover:
#   - Zalando Postgres Operator
#   - Crunchy Data PostgreSQL Operator
#   - CloudNativePG Operator (recommended)
#
# 2. MONITORING
# -------------
# Prometheus metrics via postgres_exporter:
#   - Connection pool usage
#   - Query performance
#   - Replication lag
#   - Table sizes
#   - Cache hit ratio
#
# Key metrics to monitor:
#   - pg_up: Database availability
#   - pg_stat_database_*: Database statistics
#   - pg_stat_replication_*: Replication health
#   - pg_locks_count: Lock contention
#
# 3. BACKUP & RESTORE
# -------------------
# Automated backups via CronJob (already configured)
#
# Manual backup:
#   kubectl exec -it postgres-0 -n geo-climate -- \
#     pg_dump -U geo_climate geo_climate_prod | gzip > backup.sql.gz
#
# Restore from backup:
#   gunzip -c backup.sql.gz | \
#     kubectl exec -i postgres-0 -n geo-climate -- \
#     psql -U geo_climate -d geo_climate_prod
#
# Point-in-time recovery (PITR):
#   - Enable WAL archiving
#   - Use pg_basebackup for base backups
#   - Store WAL files in S3/GCS/Azure Blob
#
# 4. PERFORMANCE TUNING
# ---------------------
# Adjust postgresql.conf based on workload:
#   - shared_buffers: 25% of RAM
#   - effective_cache_size: 75% of RAM
#   - work_mem: Total RAM / max_connections / 4
#
# Monitor slow queries:
#   SELECT * FROM pg_stat_statements ORDER BY total_exec_time DESC LIMIT 10;
#
# 5. SECURITY
# -----------
# - Use SSL/TLS for connections (add ssl=on in postgresql.conf)
# - Rotate passwords regularly
# - Use least-privilege access
# - Enable audit logging with pgaudit extension
# - Encrypt backups before storing
#
# 6. MAINTENANCE
# --------------
# Regular vacuum and analyze:
#   - Autovacuum is enabled by default
#   - Manual vacuum: VACUUM ANALYZE;
#
# Reindex periodically:
#   - REINDEX DATABASE geo_climate_prod;
#
# Update statistics:
#   - ANALYZE;
#
# ============================================================================
