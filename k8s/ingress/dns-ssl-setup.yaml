# DNS and SSL/TLS Configuration
# Complete setup for production DNS and certificate management
#
# Components:
# - cert-manager for automated SSL/TLS
# - Let's Encrypt (staging and production)
# - DNS-01 and HTTP-01 challenges
# - CloudFlare, Route53, Azure DNS integration
#
# Installation:
#   kubectl apply -f k8s/ingress/dns-ssl-setup.yaml

---
# ============================================================================
# cert-manager Installation
# ============================================================================
#
# Install cert-manager:
#   kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
#
# Verify installation:
#   kubectl get pods -n cert-manager
#
# ============================================================================

---
# ============================================================================
# Let's Encrypt Staging Issuer (for testing)
# ============================================================================

apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-staging
spec:
  acme:
    # Let's Encrypt staging server (for testing)
    server: https://acme-staging-v02.api.letsencrypt.org/directory

    # Email for expiration notifications
    email: admin@geo-climate.example.com

    # Secret to store ACME account private key
    privateKeySecretRef:
      name: letsencrypt-staging

    # HTTP-01 challenge (simple, works with most setups)
    solvers:
      - http01:
          ingress:
            class: nginx

---
# Let's Encrypt Production Issuer
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    # Let's Encrypt production server
    server: https://acme-v02.api.letsencrypt.org/directory

    # IMPORTANT: Use a valid email
    email: admin@geo-climate.example.com

    privateKeySecretRef:
      name: letsencrypt-prod

    # HTTP-01 challenge
    solvers:
      - http01:
          ingress:
            class: nginx

---
# ============================================================================
# DNS-01 Challenge (for wildcard certificates)
# ============================================================================

# CloudFlare DNS-01
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-cloudflare
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@geo-climate.example.com

    privateKeySecretRef:
      name: letsencrypt-cloudflare

    solvers:
      - dns01:
          cloudflare:
            email: cloudflare-email@example.com
            apiTokenSecretRef:
              name: cloudflare-api-token
              key: api-token

---
# AWS Route53 DNS-01
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-route53
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@geo-climate.example.com

    privateKeySecretRef:
      name: letsencrypt-route53

    solvers:
      - dns01:
          route53:
            region: us-east-1
            # Use IAM Role (IRSA) for EKS
            # accessKeyID and secretAccessKey not needed with IRSA

---
# Google Cloud DNS DNS-01
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-clouddns
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@geo-climate.example.com

    privateKeySecretRef:
      name: letsencrypt-clouddns

    solvers:
      - dns01:
          cloudDNS:
            project: your-gcp-project-id
            # Use Workload Identity for GKE
            serviceAccountSecretRef:
              name: clouddns-service-account
              key: key.json

---
# Azure DNS DNS-01
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-azuredns
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@geo-climate.example.com

    privateKeySecretRef:
      name: letsencrypt-azuredns

    solvers:
      - dns01:
          azureDNS:
            subscriptionID: your-subscription-id
            resourceGroupName: geo-climate-rg
            hostedZoneName: geo-climate.example.com
            # Use Managed Identity for AKS
            managedIdentity:
              clientID: your-client-id

---
# ============================================================================
# Certificate Resources
# ============================================================================

# Main API Certificate
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: geo-climate-api-cert
  namespace: geo-climate
spec:
  # Secret where certificate will be stored
  secretName: geo-climate-tls-secret

  # Certificate duration and renewal
  duration: 2160h  # 90 days
  renewBefore: 720h  # 30 days before expiration

  # Subject configuration
  subject:
    organizations:
      - Geo Climate Platform

  # Common name
  commonName: api.geo-climate.example.com

  # Subject Alternative Names (SANs)
  dnsNames:
    - api.geo-climate.example.com
    - www.geo-climate.example.com
    - geo-climate.example.com

  # Issuer reference
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
    group: cert-manager.io

  # Private key configuration
  privateKey:
    algorithm: RSA
    encoding: PKCS1
    size: 2048

  # Certificate usage
  usages:
    - digital signature
    - key encipherment
    - server auth

---
# Wildcard Certificate (requires DNS-01)
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: geo-climate-wildcard-cert
  namespace: geo-climate
spec:
  secretName: geo-climate-wildcard-tls

  duration: 2160h
  renewBefore: 720h

  commonName: "*.geo-climate.example.com"

  dnsNames:
    - "*.geo-climate.example.com"
    - geo-climate.example.com

  issuerRef:
    name: letsencrypt-cloudflare  # Must use DNS-01 for wildcard
    kind: ClusterIssuer

---
# Monitoring/Grafana Certificate
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: grafana-cert
  namespace: monitoring
spec:
  secretName: grafana-tls-secret

  duration: 2160h
  renewBefore: 720h

  commonName: grafana.geo-climate.example.com

  dnsNames:
    - grafana.geo-climate.example.com

  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer

---
# Prometheus Certificate
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: prometheus-cert
  namespace: monitoring
spec:
  secretName: prometheus-tls-secret

  duration: 2160h
  renewBefore: 720h

  commonName: prometheus.geo-climate.example.com

  dnsNames:
    - prometheus.geo-climate.example.com

  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer

---
# ============================================================================
# Ingress with Automatic Certificate
# ============================================================================

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: geo-climate-ingress-tls
  namespace: geo-climate
  annotations:
    # cert-manager will automatically create certificate
    cert-manager.io/cluster-issuer: "letsencrypt-prod"

    # NGINX specific
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"

    # Security headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      more_set_headers "Strict-Transport-Security: max-age=31536000; includeSubDomains; preload";
      more_set_headers "X-Frame-Options: DENY";
      more_set_headers "X-Content-Type-Options: nosniff";
      more_set_headers "X-XSS-Protection: 1; mode=block";

spec:
  tls:
    - hosts:
        - api.geo-climate.example.com
        - www.geo-climate.example.com
      secretName: geo-climate-tls-secret  # cert-manager will create this

  rules:
    - host: api.geo-climate.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: geo-climate-api
                port:
                  number: 80

    - host: www.geo-climate.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: geo-climate-api
                port:
                  number: 80

---
# ============================================================================
# DNS CONFIGURATION GUIDE
# ============================================================================
#
# Configure DNS records for your domain
#
# 1. Get LoadBalancer IP/Hostname:
#    kubectl get svc -n ingress-nginx ingress-nginx-controller
#
# 2. Create DNS records:
#
# CloudFlare:
# ----------
# Type  | Name | Content                    | Proxy | TTL
# ------|------|----------------------------|-------|-----
# A     | @    | <LOADBALANCER_IP>          | Yes   | Auto
# A     | api  | <LOADBALANCER_IP>          | Yes   | Auto
# A     | www  | <LOADBALANCER_IP>          | Yes   | Auto
# CNAME | *    | geo-climate.example.com    | Yes   | Auto
#
# Or use Terraform:
#
# resource "cloudflare_record" "api" {
#   zone_id = var.cloudflare_zone_id
#   name    = "api"
#   value   = kubernetes_service.ingress.status.0.load_balancer.0.ingress.0.ip
#   type    = "A"
#   proxied = true
# }
#
#
# AWS Route53:
# -----------
# aws route53 change-resource-record-sets \
#   --hosted-zone-id Z1234567890ABC \
#   --change-batch '{
#     "Changes": [{
#       "Action": "CREATE",
#       "ResourceRecordSet": {
#         "Name": "api.geo-climate.example.com",
#         "Type": "A",
#         "AliasTarget": {
#           "HostedZoneId": "Z1234567890ABC",
#           "DNSName": "<ELB_DNS_NAME>",
#           "EvaluateTargetHealth": false
#         }
#       }
#     }]
#   }'
#
# Or use Terraform:
#
# resource "aws_route53_record" "api" {
#   zone_id = aws_route53_zone.main.zone_id
#   name    = "api.geo-climate.example.com"
#   type    = "A"
#
#   alias {
#     name                   = kubernetes_service.ingress.status.0.load_balancer.0.ingress.0.hostname
#     zone_id                = data.aws_elb_hosted_zone_id.main.id
#     evaluate_target_health = true
#   }
# }
#
#
# Google Cloud DNS:
# ----------------
# gcloud dns record-sets create api.geo-climate.example.com \
#   --rrdatas=<LOADBALANCER_IP> \
#   --type=A \
#   --ttl=300 \
#   --zone=geo-climate-zone
#
#
# Azure DNS:
# ---------
# az network dns record-set a add-record \
#   --resource-group geo-climate-rg \
#   --zone-name geo-climate.example.com \
#   --record-set-name api \
#   --ipv4-address <LOADBALANCER_IP>
#
# ============================================================================
# SSL/TLS VERIFICATION
# ============================================================================
#
# 1. Check certificate status:
#    kubectl get certificate -A
#    kubectl describe certificate geo-climate-api-cert -n geo-climate
#
# 2. Check certificate order:
#    kubectl get certificaterequest -A
#    kubectl get order -A
#    kubectl get challenge -A
#
# 3. Test SSL:
#    curl -v https://api.geo-climate.example.com
#    openssl s_client -connect api.geo-climate.example.com:443 -servername api.geo-climate.example.com
#
# 4. SSL Labs test:
#    https://www.ssllabs.com/ssltest/analyze.html?d=api.geo-climate.example.com
#
# 5. Check cert-manager logs:
#    kubectl logs -n cert-manager deployment/cert-manager
#
# ============================================================================
# TROUBLESHOOTING
# ============================================================================
#
# Certificate not issuing:
# -----------------------
# 1. Check challenge:
#    kubectl describe challenge <challenge-name> -n geo-climate
#
# 2. Check order:
#    kubectl describe order <order-name> -n geo-climate
#
# 3. Verify DNS propagation:
#    dig api.geo-climate.example.com
#    nslookup api.geo-climate.example.com
#
# 4. Test HTTP-01 challenge:
#    curl http://api.geo-climate.example.com/.well-known/acme-challenge/<token>
#
# 5. Check ingress:
#    kubectl get ingress -n geo-climate
#    kubectl describe ingress geo-climate-ingress-tls -n geo-climate
#
# Rate limit errors:
# -----------------
# - Let's Encrypt has rate limits: 50 certificates per domain per week
# - Use staging issuer for testing
# - Delete failed certificates: kubectl delete certificate <name> -n <namespace>
#
# ============================================================================
# SECRETS SETUP (for DNS-01)
# ============================================================================
#
# CloudFlare API Token:
# --------------------
# kubectl create secret generic cloudflare-api-token \
#   --from-literal=api-token=<YOUR_CLOUDFLARE_API_TOKEN> \
#   --namespace=cert-manager
#
# Permissions needed: Zone:DNS:Edit for the specific zone
#
#
# AWS Route53 (IRSA):
# ------------------
# 1. Create IAM policy:
#    cat > route53-policy.json <<EOF
#    {
#      "Version": "2012-10-17",
#      "Statement": [
#        {
#          "Effect": "Allow",
#          "Action": "route53:GetChange",
#          "Resource": "arn:aws:route53:::change/*"
#        },
#        {
#          "Effect": "Allow",
#          "Action": [
#            "route53:ChangeResourceRecordSets",
#            "route53:ListResourceRecordSets"
#          ],
#          "Resource": "arn:aws:route53:::hostedzone/*"
#        },
#        {
#          "Effect": "Allow",
#          "Action": "route53:ListHostedZonesByName",
#          "Resource": "*"
#        }
#      ]
#    }
#    EOF
#
# 2. Create IRSA:
#    eksctl create iamserviceaccount \
#      --name cert-manager \
#      --namespace cert-manager \
#      --cluster geo-climate-prod \
#      --attach-policy-arn arn:aws:iam::ACCOUNT_ID:policy/Route53CertManagerPolicy \
#      --approve
#
# ============================================================================
